---
title: "Análise Assintórica dos algorítimos de ordenação"
author: '[Arthur Sampaio](https://www.github.com/ArthurSampaio)'
date: "19 de novembro de 2016"
output:
  pdf_document: default
  html_document:
    fig_height: 5
    fig_width: 8
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(plotly)
```

## Os dados

A metodologia para calcular os valores de tempos de execução de cada algoritmo com as mais variadas entradas foi implementada da seguinte forma:

1. Escolhe-se inteiros que variam de tamanho de 30000 à 100000 com intervalos de 1000 em cada análise. 

2. Para cada inteiro é gerado um array rândomico de tamanho igual.

3. Para cada algorítimo de ordenação (Select, Insertion, Merge e Quick) foram testados os arrays encontrados anteriormente. 

4. É escrito um csv com os dados encontrados. 

```{r, echo=FALSE, message=FALSE, warning=FALSE}
sort.data <- read.csv("~/workspace/AsymptoticAnalysis/sort.data.csv", header=T)

sort.data = sort.data %>% select(-X1337, -X30000)
names(sort.data) = c("algorithm", "time", "sample")

```

## Interpretando o gráfico

```{r, echo=FALSE, message=FALSE, warning=FALSE}
a = ggplot(sort.data, aes(x = sample/1e3, y = time, colour = algorithm)) + geom_line() + labs(title = "Análise Assintótica", x = "Tamanho do input (em mil unidades)", y = "Tempo de Execução")
(gg <- ggplotly(a))

```


Olhando rapidamente para o plot acima é possível tirar algumas conclusões rápidas: 

* O QuickSort é o melhor algorítmo de ordenação entre os analisados. 

* O pior algorítmo de ordenação, nos nossos dados, é o MergeSort. 

Nas curvas do _SelectionSort_ e _InsertionSort_ é possível observar que eles obedecem a um formato semalhante a funcão $y = n^{2}$, isto demonstra, que o tempo de execução encontrada nos nossos dados condiz com a literatura, onde o $\Theta = n^{2}$ é o valor do tempo de execução para ambos os algorítmos. 

Contudo, divergimos da teoria no segundo ponto, pois, como visto na literatura, $\Theta(MergeSort) = n.log(n)$ o que vai contra o plot acima, pois, o mergeSort é o que apresenta a maior custo de tempo de execução dentre todos os outros analisados. 

Após uma rápida investigada nos foruns achei os seguintes links do StackOverFlow ([Aqui](http://stackoverflow.com/questions/34549584/why-is-my-mergesort-shellsort-slower-than-insertion-sort), e [aqui](http://stackoverflow.com/questions/19329425/why-is-my-merge-sort-code-slower-than-insertion-sort))), que tratam sobre o assunto do porquê o mergeSort aparacer mais lento nas análises e as conclusões são as seguintes:

Para o mergeSort ser realmente eficaz é necessário utilizar apontadores para copiar os vetores, ao contrário do que é feito no meu algorítmo, onde copio os vetores por valor. Porém, não é possível, em java, utilizar apontadores algo impraticável na prática. 








